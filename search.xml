<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Broken Knowledge</title>
    <url>/2022/01/30/CTF-Broken%20knowledge/</url>
    <content><![CDATA[<p>LINUX图形界面转化成命令行界面：<code>ctrl+alt+f2</code>.</p>
<p>Crypto是用写代码解决的CTF问题.</p>
<p>虚拟机与实体机共享文件：按照<u>官方教程</u>安装VMtools后直接拖入（kali已经可以了，ubuntu好像还不行）.</p>
<p>base64编码：<a href="https://zhuanlan.zhihu.com/p/339477329">https://zhuanlan.zhihu.com/p/339477329</a>.</p>
<p>上位机：可以直接发出操控命令的计算机.</p>
<p>LINUX切换成root用户：sudo -i</p>
<img src="D:\CTF\notes' pictures\转换成root用户.png" alt="转换成root用户" style="zoom:90%;" />

<p>LINUX终端下复制粘贴：复制命令:Ctrl + Shift + C，粘贴命令:Ctrl + Shift + V.</p>
<p>图片隐写（image stegano）：将图片下载，并将其重命名为.txt文件，打开就可以获得密码.</p>
<p>凯撒密码：位移不是固定的.</p>
<p>Robots_exclusion_standard：如<a href="http://www.wechall.net/robots.txt%EF%BC%8C%E8%AF%A5">http://www.wechall.net/robots.txt，该</a> robots.txt 文件被网络爬虫用来检查他们是否被允许对你的网站或其中一部分进行爬网和索引。有时，这些文件会显示目录结构，而非保护内容不被爬网.</p>
<p>LFI漏洞：本地文件包含（Local File Include)是PHP脚本的一大特色。程序员经常把一系列功能函数都写进function.php中（包含），之后当某个文件需要时再进行调用。</p>
<blockquote>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4></blockquote>
<p>SELECT * FROM user WHERE username=’ <font color=#00BFFF>admin‘ or ‘1‘=‘1</font> ‘ AND password=’ ‘（以用户名admin登录）</p>
<p>用户名填  ‘ or 1=1#   闭合查询语句</p>
<p>一个二维码识别网站：<a href="https://online-barcode-reader.inliteresearch.com/">barcode online reader</a>.🦓真的可以扫二维码！今天做了一道题，题解就是扫斑马身上的二维码。</p>
<p>一个计算网站：<a href="https://www.wolframalpha.com/">Wolfram|Alpha: Computational Intelligence</a></p>
<blockquote>
<h4 id="代换密码与转置密码"><a href="#代换密码与转置密码" class="headerlink" title="代换密码与转置密码"></a>代换密码与转置密码</h4></blockquote>
<p>一、代换（substitution）密码（摘自<a href="https://www.jianshu.com/p/c40f45d0d44b%EF%BC%89">https://www.jianshu.com/p/c40f45d0d44b）</a></p>
<p>采用一一映射的方式，将明文每个字符逐一唯一地代换成另外的一个字符。在凯撒密码中，每个字母都按照其在字母表中的顺序向后（或向前）移动固定数目（循环移动）作为密文。而代换密码则不是简单的按顺序移位，而是完全混乱的毫无规律地进行映射。</p>
<p><strong>攻击：</strong>凯撒就是简单的字母的移位，仅仅有25种可能的密钥，暴力穷举法可以瞬间攻破它。代换密码则没法简单地看出字符的对应关系了，其可能的密钥可达26!个。</p>
<p>对于代换密码，有多种的常用的攻击方法，其中常见两种为“词频分析法”和“爬山法”。</p>
<p><strong>词频分析法</strong>:把密文中字母使用的相对频率统计出来，与日常英语中英文字母使用的相对频率进行比较，利用频率进行匹配，即密文中频率较高的字母对应于日常英语中使用频率较高的英文字母。由于要使用到数学统计的方法，此攻击方法需要用到较长的密文。可<a href="https://link.jianshu.com/?t=https://quipqiup.com/">点击这里</a>进行线上解密。</p>
<p><strong>爬山法</strong>：选择性地尝试不同解密密钥，然后给每一个解密出来的明文标记上一个适应度。解密出来的明文越接近我们的日常用的英语，适应度就越高；解密出来的明文越难读懂或者越不像我们日常用的英语，则其适应度越低。我们使用一个基于quadgram statistics的适应度计算方法。</p>
<p>下面详细描述算法步骤：</p>
<p>（1）随机生成一个key，称为parentkey，用它解密得对应的明文m1，对明文计算适应度d1。</p>
<p>（2）随机交换parentkey中的两个字符得到子密钥child，解密出对应的明文m2并计算适应度d2。</p>
<p>（3）若d1&lt;d2，则child成为新的parentkey</p>
<p>（4）不断循环进行（2）（3）直到最后的1000次循环中不再有更高的适应度生成</p>
<p>（5）回到（1）重新生成parentkey继续迭代寻找，或者由操作者终止程序</p>
<p>  重新执行（1），是为了防止（2）（3）的操作使结果陷入局部最优的困境。对于生成的明文的适应度的比较，其实可以看作是对不同解密密钥的比较，解密出来的明文的适应度越高，对应的密钥就更好。</p>
<p>quadgrams.txt和ngram_score.py可<a href="https://link.jianshu.com/?t=http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/">点击这里</a>获取。</p>
<p>二、错位（Transposition）密码</p>
<p>错位密码是一种使<strong>明文单元的位置（</strong>“单元”通常是字符或者字符串）通过一种有规律的方式进行移动的加密方法，生成的密文构成明文的一个置换。 也即明文被重新排序了。更难被攻击。</p>
]]></content>
  </entry>
  <entry>
    <title>ROS</title>
    <url>/2022/06/23/ROS/</url>
    <content><![CDATA[<p>☁参考：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">Autolabor-赵虚左</a></p>
<h4 id="0x00-安装ROS"><a href="#0x00-安装ROS" class="headerlink" title="0x00 安装ROS"></a>0x00 安装ROS</h4><p>按照1.2.4 安装ROS没有遇到问题，测试成功。泪目😭</p>
<p><img src="D:\blog\coriiiander\pictures\测试ROS.png" alt="测试ROS"></p>
<h4 id="0x01-HelloWorld简单实现"><a href="#0x01-HelloWorld简单实现" class="headerlink" title="0x01 HelloWorld简单实现"></a>0x01 HelloWorld简单实现</h4><ol>
<li>创建工作空间</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p 自定义空间名称/src</span><br><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make //ROS编译命令</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>创建功能包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//进入 src 创建 ros 包并添加依赖</span><br><span class="line">cd src</span><br><span class="line">catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure>

<p>该功能包依赖于 roscpp、rospy 与 std_msgs，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库。</p>
<blockquote>
<p>ubuntu20.04 创建文件：<code>sudo gedit 文件名</code></p>
<p>ubuntu20.04 输入中文：</p>
</blockquote>
<ol start="3">
<li>编辑源文件</li>
</ol>
<p><strong>C++版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* demo01/src/helloworld/src */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.包含 ros 的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="comment">//2.编写main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行 ros 节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">//创建 ros 节点句柄(非必须)</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">//控制台输出 hello world</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>python版</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">##指定解释器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.导包</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.编写主入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#3.初始化 ROS 节点</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="comment">#4.输出日志</span></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Hello World!!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 python 文件添加可执行权限 <code>chmod +x 自定义文件名.py</code></p>
<blockquote>
<p>ll命令查看文件属性：可读r，可写w，可执行x</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>编辑配置文件</li>
</ol>
<p><strong>C++版</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">add_executable(步骤3的源文件名(也可以随便起一个名字)</span><br><span class="line">  src/步骤3的源文件名.cpp</span><br><span class="line">)</span><br><span class="line">target_link_libraries(步骤3的源文件名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>python版</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为Python配置合适的解释器</span></span><br><span class="line">catkin_install_python(PROGRAMS scripts/自定义文件名.py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>编译并执行</li>
</ol>
<p><strong>C++版</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make</span><br><span class="line">:~$ roscore</span><br><span class="line">cd 工作空间</span><br><span class="line">source ./devel/setup.bash //将当前工作空间刷新到当前窗口下的环境变量</span><br><span class="line">rosrun 包名 C++节点(步骤3的源文件名/配置文件中随便起的名字)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>当前工作空间外执行：</strong><code>source ~/工作空间/devel/setup.bash</code>添加进<code>.bashrc</code>文件（参考安装ROS时配置环境变量，方便在任意终端中使用 ROS）</p>
<ul>
<li><p><strong>添加方式1</strong>: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</p>
</li>
<li><p><strong>添加方式2</strong>:<code>echo &quot;source ~/工作空间/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p>
</li>
</ul>
<p>添加后用<code>source .bashrc</code>重新加载它，这样以后执行不用再输入<code>source ./devel/setup.bash</code></p>
</blockquote>
<blockquote>
<p>.xxx文件是隐藏文件，用<code>ctrl+h</code>将其显现出来</p>
</blockquote>
<p><strong>python版</strong> 同C++版</p>
<h4 id="0x02-ROS集成环境搭建"><a href="#0x02-ROS集成环境搭建" class="headerlink" title="0x02 ROS集成环境搭建"></a>0x02 ROS集成环境搭建</h4>]]></content>
  </entry>
  <entry>
    <title>Misc</title>
    <url>/2022/02/12/buuMisc/</url>
    <content><![CDATA[<blockquote>
<h4 id="二维码-扫描、分离隐藏文件，暴力破解压缩包"><a href="#二维码-扫描、分离隐藏文件，暴力破解压缩包" class="headerlink" title="二维码 - 扫描、分离隐藏文件，暴力破解压缩包"></a>二维码 - 扫描、分离隐藏文件，暴力破解压缩包</h4></blockquote>
<p>①<strong>binwalk扫描文件</strong>：发现隐藏文件，藏了一个压缩包<strong>在图片中</strong>。</p>
<img src="D:\CTF\notes' pictures\binwalkQR.png" alt="binwalkQR" style="zoom:70%;" />



<p>②<strong>分离隐藏文件</strong>：四种方法<a href="https://www.cnblogs.com/jiaxinguoguo/p/7351202.html">https://www.cnblogs.com/jiaxinguoguo/p/7351202.html</a></p>
<p>（1）<strong>dd命令</strong>分离隐藏文件：<code>dd if=QR_code.png of=flag1.zip skip=471 bs=1</code> </p>
<p>​    ※bs为其他值会报错“无法跳至指定偏移量”，且文件不正常。</p>
<ul>
<li><p><strong>LINUX dd命令：</strong></p>
<p>dd命令主要用来块拷贝一个指定大小的文件，并在拷贝的同时进行指定的转换。<u>参数注释：</u></p>
<p>1.if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</p>
<p>2.of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</p>
<p>3.skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</p>
<p>4.bs=bytes：设置读入/输出的块大小为bytes个字节。</p>
<p>……可以灵活使用参数进行<u>磁盘测试</u>etc.</p>
</li>
</ul>
<img src="D:\CTF\notes' pictures\binwalk更改skip.png" alt="binwalk更改skip" style="zoom:67%;" />

<p>（2）也可在<font color=#00BFFF>一定环境配置(java)下</font>使用**<code>binwalk -e</code>**来分离文件。</p>
<img src="D:\CTF\notes' pictures\binwalk -e报错.png" alt="binwalk -e报错" style="zoom:70%;" />



<p>③破解压缩包密码</p>
<p>（1）<strong>fcrackzip</strong>暴力破解<strong>zip</strong>压缩包密码：下载安装<code>sudo apt-get install fcrackzip</code>，命令<code>fcrackzip -b -c1 -l 1-4 -u /home/vivi/flag1.zip</code></p>
<ul>
<li>参数解释：-b 暴力破解模式，-c 指定掩码类型（a=a-z; 1=0-9; !=特殊字符），-l 密码长度，-u 压缩文件名</li>
</ul>
<p>※只能破解zip，rar就不行了。</p>
<p>（2）<strong>rar</strong>用<strong>ARCHPR</strong>：注意设置攻击类型、范围与掩码。</p>
<ul>
<li><font color=#00BFFF>攻击类型</font></li>
</ul>
<blockquote>
<h4 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h4></blockquote>
<p>1.万能的txt读程序源码</p>
<p>2.用html加载图片</p>
<img src="D:\CTF\notes' pictures\html加载图片.png" alt="html加载图片" style="zoom:67%;" />



<blockquote>
<h4 id="文件中的秘密"><a href="#文件中的秘密" class="headerlink" title="文件中的秘密"></a>文件中的秘密</h4></blockquote>
<p>图片属性中也能藏信息</p>
<blockquote>
<h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a><font color=#00BFFF>wireshark</font></h4></blockquote>
<p>wireshark&amp;被嗅探的流量两题，不知道wireshark怎么用。</p>
<blockquote>
<h4 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h4></blockquote>
<p>只可在无损压缩或者无压缩的图片（.bmp）上实现lsb隐写。</p>
<p>.jpg：对像数进行了<strong>有损</strong>压缩，<strong>无法用LSB隐写</strong>。</p>
<p>.bmp：把所有的像数都按原样储存，一般特别大，<strong>没有进行压缩</strong>。可LSB隐写。</p>
<p>.png：一种<strong>无损</strong>压缩的位图片形格式。可LSB隐写。</p>
<p>图像像数一般由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即共有256种颜色，一共包含了256的3次方的颜色，即16777216种颜色。而人类的眼睛可以区分约1000万种不同的颜色，这就意味着人类的眼睛无法区分余下的大约6777216种颜色。</p>
<img src="D:\CTF\notes' pictures\RGB.png" alt="RGB" style="zoom:50%;" />

<p>LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，每个像数可以携带<strong>3比特</strong>的信息。</p>
<img src="D:\CTF\notes' pictures\最低有效位.png" alt="最低有效位" style="zoom: 35%;" />

<p>图片通道：一幅完整的图像，红色绿色蓝色三个通道缺一不可。</p>
<blockquote>
<p>（PhotoShop中）关闭红色通道，图像偏青色；关闭绿色通道，图像偏红色；关闭蓝色通道，图像偏黄色；Alpha通道是一个8位的灰度通道，也可理解为透明度。</p>
</blockquote>
<p>配置java环境后用<strong>Stegsolve</strong>打开LSB隐写的图片，查看<code>Red plane 0</code>、<code>Grenn plane 0</code>、<code>Blue plane0</code>通道上方有东西，调整保存DataAnalyse数据生成图片。</p>
<img src="D:\CTF\notes' pictures\Stegsolve_BluePlane0.png" alt="Stegsolve_BluePlane0" style="zoom:50%;" />

<img src="D:\CTF\notes' pictures\StegsolveDataExtract.png" alt="StegsolveDataExtract" style="zoom:55%;" />



<blockquote>
<h4 id="zip伪加密-十六进制编辑器"><a href="#zip伪加密-十六进制编辑器" class="headerlink" title="zip伪加密 - 十六进制编辑器"></a>zip伪加密 - 十六进制编辑器</h4></blockquote>
<p>010editor template下载相关插件，修改参数。</p>
<p>zip伪加密：不需要真的解密，修改相应参数后再打开就不用密码了。一般在压缩源文件数据区全局方式位标记处，真加密为 09 00，伪加密为00 00，而这道题把两处标记全改过了，所以应当改两处。</p>
<img src="D:\CTF\notes' pictures\伪加密标记位.png" alt="伪加密标记位" style="zoom:70%;" />

<img src="D:\CTF\notes' pictures\010editor改参数.png" alt="010editor改参数" style="zoom:65%;" />



<blockquote>
<h4 id="另外一个世界"><a href="#另外一个世界" class="headerlink" title="另外一个世界"></a>另外一个世界</h4></blockquote>
<p>二进制八个一组转ASCII码</p>
<blockquote>
<h4 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h4></blockquote>
<p>.png中隐藏.zlib文件。</p>
<p>※**.zlib文件**：用于数据压缩的开源软件包。</p>
<p>Stegsolve打开图片，Data Analyse按上LSB加密设置（MSB也可）（主要是查看隐写）调出数据，看到文件头为504B0304（zip和zlib文件头一样）。各类型file的文件头尾：<a href="http://www.mamicode.com/info-detail-2468733.html%E3%80%82">http://www.mamicode.com/info-detail-2468733.html。</a></p>
<p>不用Windows自带的压缩器打开压缩包后看到一个无后缀的ELF文件。在其中查找“hctf”。</p>
<p>※<strong>ELF文件</strong>：一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。是UNIX系统实验室（USL）作为应用程序二进制接口而开发和发布的，也是Linux的主要可执行文件格式。</p>
<blockquote>
<h4 id="假如给我三天光明"><a href="#假如给我三天光明" class="headerlink" title="假如给我三天光明"></a>假如给我三天光明</h4></blockquote>
<p>用Audacity处理摩斯电码：200宽度的表示_ 50宽度的表示 . 距离50宽度的连读 50宽度外的表示停顿。</p>
<p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></p>
<blockquote>
<h4 id="神秘龙卷风"><a href="#神秘龙卷风" class="headerlink" title="神秘龙卷风"></a>神秘龙卷风</h4></blockquote>
<p>brainfuck（一种计算机语言）加密。<a href="http://bf.doleczek.pl/">http://bf.doleczek.pl/</a></p>
<blockquote>
<h4 id="后门查杀"><a href="#后门查杀" class="headerlink" title="后门查杀"></a>后门查杀</h4></blockquote>
<p>解压后用D盾。</p>
<p><strong>后门</strong>：指绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。有攻击者建立的后门，也有程序员自己在软件内创建后门以方便测试或者修改程序中的缺陷。后者在软件发布时，后门被有意或者无意忽视了，没有被删除，那么这个软件天生就存在后门，安装该软件的主机就不可避免的引入了后门。</p>
<blockquote>
<h4 id="荷兰宽带数据泄露"><a href="#荷兰宽带数据泄露" class="headerlink" title="荷兰宽带数据泄露"></a>荷兰宽带数据泄露</h4></blockquote>
<p>.bin 文件是一个路由配置文件，路由器信息数据，一般包含账号密码。</p>
<p>用<font color=#00BFFF>RouterPassView</font></p>
<blockquote>
<h4 id="面具下的flag"><a href="#面具下的flag" class="headerlink" title="面具下的flag"></a>面具下的flag</h4></blockquote>
<p>binwalk分离出压缩包，010editor修改伪加密（不修改伪加密linux上打不开压缩包，看不到vmdk文件），再在linux里解压vmdk文件（windows解不了压，linux里解压才能看到txt文件）</p>
<p><strong>vmdk文件</strong>：VMDK是虚拟机VMware创建的虚拟硬盘格式，文件存在于VMware文件系统中，被称为VMFS（虚拟机文件系统）。一个VMDK文件代表VMFS在虚拟机上的一个物理硬盘驱动。所有用户数据和有关虚拟服务器的配置信息都存储在VMDK文件中。</p>
<blockquote>
<h4 id="九连环"><a href="#九连环" class="headerlink" title="九连环"></a>九连环</h4></blockquote>
]]></content>
  </entry>
  <entry>
    <title>Reverse</title>
    <url>/2022/02/25/buuReverse/</url>
    <content><![CDATA[<h4 id="0x00-IDA"><a href="#0x00-IDA" class="headerlink" title="0x00 IDA"></a>0x00 IDA</h4><p>逆向工程分为动态分析(OLLYDBG)和静态分析(IDA)。IDA无法分析自解压运行(.exe)的文件，通常用OLLYDBG动态跟踪，等程序完成自解压后从内存中将解压后的代码完整的挖下来形成文件，再由IDA进行静态分析。</p>
<p><code>shift+F12</code>查找字符串    <code>ctrl+x</code>查看流程图    <code>F5</code>查看源代码</p>
<h4 id="0x01-壳"><a href="#0x01-壳" class="headerlink" title="0x01 壳"></a>0x01 壳</h4><p><code>exeinfo pe</code>查壳，发现是UPX-&gt;Markus &amp; …的壳。</p>
<img src="D:\CTF\notes' pictures\exeinfopeHappyNewYear.png" alt="exeinfopeHappyNewYear" style="zoom:50%;" />

<p><strong>壳</strong>：实质上是一个子程序，它在程序运行时首先取得控制权并对exe、com、和dll等程序文件进行压缩，同时隐藏程序真正的OEP。大多数病毒就是基于此原理，从而防止被杀毒软件扫描。</p>
<blockquote>
<p>EP是程序的入口点，OEP是程序的原始入口点。一个正常的程序只有EP，只有入口点被修改的程序（加壳等），才会拥有OEP。壳就是一把锁，OEP就是锁孔。</p>
<p>UPX：一种可执行程序文件压缩器/压缩壳，压缩壳主要功能是压缩PE文件(比如exe,dll等文件)。壳upx是一种保护程序，一般是EXE文件的一种外保护措施。</p>
</blockquote>
<p>脱壳方法之一：<strong>ESP定律</strong>（堆栈平衡定律）</p>
]]></content>
  </entry>
  <entry>
    <title>Web</title>
    <url>/2022/02/10/buuWeb/</url>
    <content><![CDATA[<blockquote>
<h4 id="WarmUp"><a href="#WarmUp" class="headerlink" title="WarmUp"></a>WarmUp</h4></blockquote>
<p>代码审计：hint.php?../…/…/…/…/ffffllllaaaagggg 传入 checkFile( ) 要经历一次白名单验证、一次?过滤得 hint.php 再进行一次白名单验证返回为真，即得到flag。</p>
<p>☁<code>http://34774e72-ec93-4cf6-9472-b655238aff59.node4.buuoj.cn:81/index.php?file=hint.php?../../../../../ffffllllaaaagggg</code> <font color=#00BFFF>为什么有index.php?file=</font></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="comment">//highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">      </span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;<span class="variable">$page</span></span>)</span></span><br><span class="line"><span class="function">          //<span class="title">cehckFile</span>(<span class="params"></span>)进行了3次白名单检测、 2次问号过滤、一次<span class="title">URL</span>解码</span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">              <span class="comment">//白名单列表</span></span><br><span class="line">              <span class="variable">$whitelist</span> = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">              <span class="comment">//isset()检测变量是否已设置并且非 NULL;  </span></span><br><span class="line">              <span class="comment">//is_string()判断变量是否是字符串</span></span><br><span class="line">              <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="variable">$page</span>) || !<span class="title function_ invoke__">is_string</span>(<span class="variable">$page</span>)) &#123;</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it A&quot;</span>;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//检测传进来的值是否匹配白名单列表$whitelist</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//过滤问号的函数(如果$page的值有？则从?之前提取字符串)</span></span><br><span class="line">               <span class="comment">//mb_substr() 函数返回字符串的一部分，substr() 只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。</span></span><br><span class="line">             <span class="variable">$_page</span> = <span class="title function_ invoke__">mb_substr</span>(</span><br><span class="line">                 <span class="variable">$page</span>,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)//返回<span class="variable">$page</span>.里?号出现的第一个位置</span><br><span class="line">             );</span><br><span class="line"> </span><br><span class="line">              <span class="comment">//第二次检测传进来的值是否匹配白名单列表$whitelist</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//url对$page解码</span></span><br><span class="line">             <span class="variable">$_page</span> = <span class="title function_ invoke__">urldecode</span>(<span class="variable">$page</span>);</span><br><span class="line"> </span><br><span class="line">             <span class="comment">//第二次过滤问号的函数(如果$page的值有？则从?之前提取字符串)</span></span><br><span class="line">             <span class="variable">$_page</span> = <span class="title function_ invoke__">mb_substr</span>(</span><br><span class="line">                 <span class="variable">$_page</span>,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">             );</span><br><span class="line">             <span class="comment">//第三次检测传进来的值是否匹配白名单列表$whitelist</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; <span class="title function_ invoke__">is_string</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::<span class="title function_ invoke__">checkFile</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="comment">/*如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。</span></span><br><span class="line"><span class="comment">        否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。*/</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<h4 id="Include-1"><a href="#Include-1" class="headerlink" title="Include 1"></a>Include 1</h4></blockquote>
<p>靶场环境：<a href="http://78d5d456-3136-4627-9d09-4cdbb8f1af18.node4.buuoj.cn:81/">http://78d5d456-3136-4627-9d09-4cdbb8f1af18.node4.buuoj.cn:81</a></p>
<p>文件包含漏洞，读取代码（PHP伪协议）：<code>php://filter/read=convert.base64-encode/resource=xxx.php</code></p>
<p>然后构造playload：<code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></p>
<blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4></blockquote>
]]></content>
  </entry>
  <entry>
    <title>setupBlog</title>
    <url>/2022/06/20/setupBlog/</url>
    <content><![CDATA[<h4 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h4><p>参考保姆级教学<a href="https://b23.tv/MLKFY">https://b23.tv/MLKFY</a> B站永远的神！</p>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s</span></span><br><span class="line">Usage: hexo &lt;command&gt;</span><br></pre></td></tr></table></figure>

<p>没有打开最近具体文件的文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span></span><br><span class="line">...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/coriiiander/coriiiander.github.io.git/&#x27;: Failed to connect to localhost port 8080 after 150217 ms: Connection refused</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\blog\coriiiander\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (node:events:390:28)</span><br><span class="line">      at ChildProcess.cp.emit (D:\blog\coriiiander\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>

<p>把_config.yml http协议改成git协议。</p>
<p>新版<code>hexo d</code> 后直接部署，无须输入<code>token</code>。</p>
<h4 id="美化博客"><a href="#美化博客" class="headerlink" title="美化博客"></a>美化博客</h4><p>更换主题页面报错，注意查看github主题源模板处安装依赖提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">extends widget/base block append head link(rel=&#x27;stylesheet&#x27;, href= url_for(&quot;/style/widget-post-list.css&quot;)) block content include widget/widget-post-list block sidebar include widget/widget-search if theme.widgets.includes(&#x27;profile&#x27;) include widget/widget-profile if theme.widgets.includes(&#x27;recent_posts&#x27;) include widget/widget-recent if theme.widgets.includes(&#x27;category&#x27;) &amp;&amp; site.categories.length &gt; 0 include widget/widget-categories if theme.widgets.includes(&#x27;archive&#x27;) include widget/widget-archives if theme.widgets.includes(&#x27;tag&#x27;) &amp;&amp; site.tags.length &gt; 0 include widget/widget-tag </span><br></pre></td></tr></table></figure>

<p>本地部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>上传github</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
