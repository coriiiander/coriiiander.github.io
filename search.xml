<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Broken Knowledge</title>
    <url>/2022/01/30/CTF-Broken%20knowledge/</url>
    <content><![CDATA[<p>LINUX图形界面转化成命令行界面：<code>ctrl+alt+f2</code>.</p>
<p>Crypto是用写代码解决的CTF问题.</p>
<p>虚拟机与实体机共享文件：按照<u>官方教程</u>安装VMtools后直接拖入（kali已经可以了，ubuntu好像还不行）.</p>
<p>base64编码：<a href="https://zhuanlan.zhihu.com/p/339477329">https://zhuanlan.zhihu.com/p/339477329</a>.</p>
<p>上位机：可以直接发出操控命令的计算机.</p>
<p>LINUX切换成root用户：sudo -i</p>
<img src="D:\CTF\notes' pictures\转换成root用户.png" alt="转换成root用户" style="zoom:90%;" />

<p>LINUX终端下复制粘贴：复制命令:Ctrl + Shift + C，粘贴命令:Ctrl + Shift + V.</p>
<p>图片隐写（image stegano）：将图片下载，并将其重命名为.txt文件，打开就可以获得密码.</p>
<p>凯撒密码：位移不是固定的.</p>
<p>Robots_exclusion_standard：如<a href="http://www.wechall.net/robots.txt%EF%BC%8C%E8%AF%A5">http://www.wechall.net/robots.txt，该</a> robots.txt 文件被网络爬虫用来检查他们是否被允许对你的网站或其中一部分进行爬网和索引。有时，这些文件会显示目录结构，而非保护内容不被爬网.</p>
<p>LFI漏洞：本地文件包含（Local File Include)是PHP脚本的一大特色。程序员经常把一系列功能函数都写进function.php中（包含），之后当某个文件需要时再进行调用。</p>
<blockquote>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4></blockquote>
<p>SELECT * FROM user WHERE username=’ <font color=#00BFFF>admin‘ or ‘1‘=‘1</font> ‘ AND password=’ ‘（以用户名admin登录）</p>
<p>用户名填  ‘ or 1=1#   闭合查询语句</p>
<p>一个二维码识别网站：<a href="https://online-barcode-reader.inliteresearch.com/">barcode online reader</a>.🦓真的可以扫二维码！今天做了一道题，题解就是扫斑马身上的二维码。</p>
<p>一个计算网站：<a href="https://www.wolframalpha.com/">Wolfram|Alpha: Computational Intelligence</a></p>
<blockquote>
<h4 id="代换密码与转置密码"><a href="#代换密码与转置密码" class="headerlink" title="代换密码与转置密码"></a>代换密码与转置密码</h4></blockquote>
<p>一、代换（substitution）密码（摘自<a href="https://www.jianshu.com/p/c40f45d0d44b%EF%BC%89">https://www.jianshu.com/p/c40f45d0d44b）</a></p>
<p>采用一一映射的方式，将明文每个字符逐一唯一地代换成另外的一个字符。在凯撒密码中，每个字母都按照其在字母表中的顺序向后（或向前）移动固定数目（循环移动）作为密文。而代换密码则不是简单的按顺序移位，而是完全混乱的毫无规律地进行映射。</p>
<p><strong>攻击：</strong>凯撒就是简单的字母的移位，仅仅有25种可能的密钥，暴力穷举法可以瞬间攻破它。代换密码则没法简单地看出字符的对应关系了，其可能的密钥可达26!个。</p>
<p>对于代换密码，有多种的常用的攻击方法，其中常见两种为“词频分析法”和“爬山法”。</p>
<p><strong>词频分析法</strong>:把密文中字母使用的相对频率统计出来，与日常英语中英文字母使用的相对频率进行比较，利用频率进行匹配，即密文中频率较高的字母对应于日常英语中使用频率较高的英文字母。由于要使用到数学统计的方法，此攻击方法需要用到较长的密文。可<a href="https://link.jianshu.com/?t=https://quipqiup.com/">点击这里</a>进行线上解密。</p>
<p><strong>爬山法</strong>：选择性地尝试不同解密密钥，然后给每一个解密出来的明文标记上一个适应度。解密出来的明文越接近我们的日常用的英语，适应度就越高；解密出来的明文越难读懂或者越不像我们日常用的英语，则其适应度越低。我们使用一个基于quadgram statistics的适应度计算方法。</p>
<p>下面详细描述算法步骤：</p>
<p>（1）随机生成一个key，称为parentkey，用它解密得对应的明文m1，对明文计算适应度d1。</p>
<p>（2）随机交换parentkey中的两个字符得到子密钥child，解密出对应的明文m2并计算适应度d2。</p>
<p>（3）若d1&lt;d2，则child成为新的parentkey</p>
<p>（4）不断循环进行（2）（3）直到最后的1000次循环中不再有更高的适应度生成</p>
<p>（5）回到（1）重新生成parentkey继续迭代寻找，或者由操作者终止程序</p>
<p>  重新执行（1），是为了防止（2）（3）的操作使结果陷入局部最优的困境。对于生成的明文的适应度的比较，其实可以看作是对不同解密密钥的比较，解密出来的明文的适应度越高，对应的密钥就更好。</p>
<p>quadgrams.txt和ngram_score.py可<a href="https://link.jianshu.com/?t=http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/">点击这里</a>获取。</p>
<p>二、错位（Transposition）密码</p>
<p>错位密码是一种使<strong>明文单元的位置（</strong>“单元”通常是字符或者字符串）通过一种有规律的方式进行移动的加密方法，生成的密文构成明文的一个置换。 也即明文被重新排序了。更难被攻击。</p>
]]></content>
  </entry>
  <entry>
    <title>PWN</title>
    <url>/2022/07/03/PWN/</url>
    <content><![CDATA[<h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><blockquote>
<p>nc命令：全称netcat，用于设置路由器，能通过 TCP 和 UDP 在网络中读写数据，通过与其他工具结合和重定向。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>ROS</title>
    <url>/2022/06/23/ROS/</url>
    <content><![CDATA[<p>☁参考：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">Autolabor-赵虚左</a>  <a href="http://wiki.ros.org/cn/ROS/Tutorials">ROS手册</a></p>
<p>最初是为后来没去的暑假实习硬件岗位学的ROS，这东西蛮有趣、蛮好上手（比起二进制安全（根本原因是我自学能力差））的。学都学了，干脆多学一点。</p>
<h4 id="0x00-安装ROS"><a href="#0x00-安装ROS" class="headerlink" title="0x00 安装ROS"></a>0x00 安装ROS</h4><p>按照1.2.4 安装ROS没有遇到问题，测试成功。</p>
<p><img src="D:\blog\coriiiander\source_posts\pictures\测试ROS.png" alt="测试ROS"></p>
<h4 id="0x01-HelloWorld简单实现"><a href="#0x01-HelloWorld简单实现" class="headerlink" title="0x01 HelloWorld简单实现"></a>0x01 HelloWorld简单实现</h4><p><strong>vscode图形界面下总结</strong>：/DEMO/src → 右击Create Catkin Package → 输入包名和依赖包 → 包下src中创建c文件 → 修改CMakeLists文件 → catkin_make:debug终端下编译 → 0x01 5 执行</p>
<p>​    python在功能包下新建scripts文件夹 → 创建c文件 → …</p>
<h5 id="1-创建工作空间"><a href="#1-创建工作空间" class="headerlink" title="1.创建工作空间"></a>1.创建工作空间</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p 自定义空间名称/src</span><br><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make //ROS编译命令</span><br></pre></td></tr></table></figure>



<h5 id="2-创建功能包"><a href="#2-创建功能包" class="headerlink" title="2.创建功能包"></a>2.创建功能包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//进入 src 创建 ros 包并添加依赖</span><br><span class="line">cd src</span><br><span class="line">catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs</span><br></pre></td></tr></table></figure>

<p>该功能包依赖于 roscpp、rospy 与 std_msgs，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库。</p>
<blockquote>
<p>ubuntu20.04 创建文件：<code>sudo gedit 文件名</code></p>
<p>ubuntu20.04 输入中文：<a href="https://blog.csdn.net/u013819452/article/details/125324881">https://blog.csdn.net/u013819452/article/details/125324881</a></p>
</blockquote>
<h5 id="3-编辑源文件"><a href="#3-编辑源文件" class="headerlink" title="3.编辑源文件"></a>3.编辑源文件</h5><p><strong>C++版</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* demo01/src/helloworld/src */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.包含 ros 的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="comment">//2.编写main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行 ros 节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">//创建 ros 节点句柄(非必须)</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">//控制台输出 hello world</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>python版</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">##指定解释器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.导包</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.编写主入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#3.初始化 ROS 节点</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="comment">#4.输出日志</span></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Hello World!!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为 python 文件添加可执行权限 <code>chmod +x 自定义文件名.py</code></p>
<blockquote>
<p>自定义文件名为*，表示所有文件；ll命令查看文件属性：可读r，可写w，可执行x 。</p>
</blockquote>
</li>
</ul>
<h5 id="4-编辑配置文件"><a href="#4-编辑配置文件" class="headerlink" title="4.编辑配置文件"></a>4.编辑配置文件</h5><p><strong>C++版</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">add_executable(步骤3的源文件名(也可以随便起一个名字)</span><br><span class="line">  src/步骤3的源文件名.cpp</span><br><span class="line">)</span><br><span class="line">target_link_libraries(步骤3的源文件名</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>python版</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为Python配置合适的解释器 1.安装 2.定位解释器</span></span><br><span class="line"><span class="comment"># 未配置CMakeList.txt是解决方法：1.直接声明解释器为python3（不建议） 2.通过软链接将 python 链接到 python3（建议）</span></span><br><span class="line">catkin_install_python(PROGRAMS scripts/自定义文件名.py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="5-编译并执行"><a href="#5-编译并执行" class="headerlink" title="5.编译并执行"></a>5.编译并执行</h5><p><strong>C++版</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 自定义空间名称</span><br><span class="line">catkin_make（也可在vscode下catkin_make:debug终端下ctrl + shift + b编译）</span><br><span class="line">:~$ roscore（根目录）</span><br><span class="line">cd 工作空间</span><br><span class="line">source ./devel/setup.bash //将当前工作空间刷新到当前窗口下的环境变量</span><br><span class="line">rosrun 包名 C++节点(步骤3的源文件名/配置文件中随便起的名字)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>当前工作空间外执行：</strong><code>source ~/工作空间/devel/setup.bash</code>添加进<code>.bashrc</code>文件（参考安装ROS时配置环境变量，方便在任意终端中使用 ROS）</p>
<ul>
<li><p><strong>添加方式1</strong>: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</p>
</li>
<li><p><strong>添加方式2</strong>:<code>echo &quot;source ~/工作空间/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p>
</li>
</ul>
<p>添加后用<code>source .bashrc</code>重新加载它，这样以后执行不用再输入<code>source ./devel/setup.bash</code></p>
</blockquote>
<blockquote>
<p>.xxx文件是隐藏文件，用<code>ctrl+h</code>将其显现出来</p>
</blockquote>
<p><strong>python版</strong> 同C++版</p>
<h4 id="0x02-ROS集成环境搭建"><a href="#0x02-ROS集成环境搭建" class="headerlink" title="0x02 ROS集成环境搭建"></a>0x02 ROS集成环境搭建</h4><h5 id="安装终端"><a href="#安装终端" class="headerlink" title="安装终端"></a>安装终端</h5><p>ROS中，频繁用到终端且需要同时开启多个窗口，推荐Terminator及其快捷键。</p>
<h5 id="安装VScode"><a href="#安装VScode" class="headerlink" title="安装VScode"></a>安装VScode</h5><p>☁详细看1.4.2 P28</p>
<blockquote>
<p><code>ctrl + =</code>放大  <code>ctrl + -</code>缩小  <code>ctrl + shift + b</code>编译  <code>ctrl + /</code>取消注释 <code>ctrl + shift + A</code>加注释</p>
</blockquote>
<h5 id="安装launch文件"><a href="#安装launch文件" class="headerlink" title="安装launch文件"></a>安装launch文件</h5><p>一个程序中可能需要启动多个节点，对“调用 rosrun 逐一启动”进行优化：使用 launch 文件，可以一次性启动多个 ROS 节点。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 添加被执行的节点 pkg是包 type是节点 name是节点名 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 乌龟GUI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;helloworld&quot;</span> <span class="attr">type</span>=<span class="string">&quot;demo_hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;key1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参考执行乌龟程序时的<code>rosrun turtlesim turtlesim_node</code></p>
<h4 id="0x03-ROS架构"><a href="#0x03-ROS架构" class="headerlink" title="0x03 ROS架构"></a>0x03 ROS架构</h4><p>💦本节建议在对ROS有一定经验后再回来学习（P31-P35）</p>
<h5 id="ROS文件系统"><a href="#ROS文件系统" class="headerlink" title="ROS文件系统"></a>ROS文件系统</h5><h5 id="ROS文件系统相关命令"><a href="#ROS文件系统相关命令" class="headerlink" title="ROS文件系统相关命令"></a>ROS文件系统相关命令</h5><ol>
<li>执行</li>
</ol>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">roscore</span></span><br><span class="line"><span class="variable">roscore</span> -<span class="variable">p</span> <span class="function"><span class="title">xxxx</span>(指定端口号)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>roscore是 ROS 的系统先决条件节点和程序的集合， 必须运行 roscore 才能使 ROS 节点进行通信。</p>
</li>
<li><p>roscore 将启动：ros master，ros 参数服务器，rosout 日志节点。</p>
</li>
<li><p>```shell<br>vivi@ubuntu:~$ roscore</p>
<h1 id="日志写到哪去了"><a href="#日志写到哪去了" class="headerlink" title="日志写到哪去了"></a>日志写到哪去了</h1><p>… logging to /home/vivi/.ros/log/a6cd7df8-f5ea-11ec-8a5d-4d68047558b7/roslaunch-ubuntu-4173.log<br>Checking log directory for disk usage. This may take a while.<br>Press Ctrl-C to interrupt<br>Done checking log file disk usage. Usage is &lt;1GB.</p>
<h1 id="在该端口上启动roslaunch-server"><a href="#在该端口上启动roslaunch-server" class="headerlink" title="在该端口上启动roslaunch server"></a>在该端口上启动roslaunch server</h1><p>started roslaunch server <a href="http://ubuntu:39577/">http://ubuntu:39577/</a><br>ros_comm version 1.15.14</p>
<h1 id="ros摘要"><a href="#ros摘要" class="headerlink" title="ros摘要"></a>ros摘要</h1><h1 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h1><p>PARAMETERS</p>
<ul>
<li>/rosdistro: noetic</li>
<li>/rosversion: 1.15.14</li>
</ul>
<h1 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h1><p>NODES</p>
<p>auto-starting new master # 启动新的master节点<br>process[master]: started with pid [4183]<br>ROS_MASTER_URI=<a href="http://ubuntu:11311/">http://ubuntu:11311/</a></p>
<p>setting /run_id to a6cd7df8-f5ea-11ec-8a5d-4d68047558b7<br>process[rosout-1]: started with pid [4193] # 启动日志输出rosout节点<br>started core service [/rosout]</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rosrun 包名 可执行文件名</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 运行指定的ROS节点，如`rosrun turtlesim turtlesim_node`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>roslaunch 包名 launch文件名</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 执行某个包下的 launch 文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### ROS计算图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 0x04 ROS通信机制</span></span><br><span class="line"></span><br><span class="line">ROS中每个功能点都是一个单独的进程，ROS是进程（也称为Nodes）的分布式框架。不同的进程是如何通信的？</span><br><span class="line"></span><br><span class="line">- 话题通信(发布订阅模式)</span><br><span class="line">- 服务通信(请求响应模式)</span><br><span class="line">- 参数服务器(参数共享模式)</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 话题通信</span></span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;D:\blog\coriiiander\source\_posts\pictures\通信机制.jpg&quot;</span> alt=<span class="string">&quot;通信机制&quot;</span> style=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">适用于不断更新的数据传输相关的应用场景。理论模型（master注册时延会导致先接收后发送接收不到前几条数据，可通过休眠解决该问题&lt;我的一直接收不到数据&gt;）：</span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;D:\blog\coriiiander\source\_posts\pictures\理论模型.jpg&quot;</span> alt=<span class="string">&quot;理论模型&quot;</span> style=<span class="string">&quot;zoom:30%;&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. **话题通信基本操作** - 最基本的发布订阅模型，发布方以固定频率发送一段文本，订阅方接收文本并输出。</span><br><span class="line"></span><br><span class="line">**C++**</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">/*</span><br><span class="line">    需求: 实现基本的话题通信，一方发布数据，一方接收数据，</span><br><span class="line">         实现的关键点:</span><br><span class="line">         <span class="number">1</span>.发送方</span><br><span class="line">         <span class="number">2</span>.接收方</span><br><span class="line">         <span class="number">3</span>.数据(此处为普通文本)</span><br><span class="line"></span><br><span class="line">         PS: 二者需要设置相同的话题</span><br><span class="line">/*</span><br><span class="line">/*</span><br><span class="line">    消息发布方:</span><br><span class="line">        循环发布信息:HelloWorld 后缀数字编号</span><br><span class="line"></span><br><span class="line">    实现流程:</span><br><span class="line">        <span class="number">1</span>.包含头文件 </span><br><span class="line">        <span class="number">2</span>.初始化 ROS 节点:命名(唯一)</span><br><span class="line">        <span class="number">3</span>.实例化 ROS 句柄</span><br><span class="line">        <span class="number">4</span>.实例化 发布者 对象</span><br><span class="line">        <span class="number">5</span>.组织被发布的数据，并编写逻辑发布数据</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span>.包含头文件 </span><br><span class="line"><span class="comment">#include &quot;ros/ros.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/String.h&quot; //普通文本类型的消息</span></span><br><span class="line"><span class="comment">#include &lt;sstream&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char  *argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="regexp">//</span>设置编码</span><br><span class="line">    setlocale(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span><span class="number">2</span>.初始化 ROS 节点:命名(唯一)</span><br><span class="line">    <span class="regexp">//</span> 参数<span class="number">1</span>和参数<span class="number">2</span> 后期为节点传值会使用</span><br><span class="line">    <span class="regexp">//</span> 参数<span class="number">3</span> 是节点名称，是一个标识符，需要保证运行后，在 ROS 网络拓扑中唯一</span><br><span class="line">    ros::init(argc,argv,<span class="string">&quot;talker&quot;</span>);</span><br><span class="line">    <span class="regexp">//</span><span class="number">3</span>.实例化 ROS 句柄</span><br><span class="line">    ros::NodeHandle nh;<span class="regexp">//</span>该类封装了 ROS 中的一些常用功能</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span><span class="number">4</span>.实例化 发布者 对象</span><br><span class="line">    <span class="regexp">//</span>泛型: 发布的消息类型</span><br><span class="line">    <span class="regexp">//</span>参数<span class="number">1</span>: 要发布到的话题</span><br><span class="line">    <span class="regexp">//</span>参数<span class="number">2</span>: 队列中最大保存的消息数，超出此阀值时，先进的先销毁(时间早的先销毁)</span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span><span class="number">5</span>.组织被发布的数据，并编写逻辑发布数据</span><br><span class="line">    <span class="regexp">//</span>数据(动态组织)</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    <span class="regexp">//</span> msg.data = <span class="string">&quot;你好啊！！！&quot;</span>;</span><br><span class="line">    std::string msg_front = <span class="string">&quot;Hello 你好！&quot;</span>; <span class="regexp">//</span>消息前缀</span><br><span class="line">    int count = <span class="number">0</span>; <span class="regexp">//</span>消息计数器</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>逻辑(一秒<span class="number">10</span>次)</span><br><span class="line">    ros::Rate r(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>节点不死</span><br><span class="line">    <span class="keyword">while</span> (ros::ok())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">//</span>使用 stringstream 拼接字符串与编号</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; msg_front &lt;&lt; count;</span><br><span class="line">        msg.data = ss.str();</span><br><span class="line">        <span class="regexp">//</span>发布消息</span><br><span class="line">        pub.publish(msg);</span><br><span class="line">        <span class="regexp">//</span>加入调试，打印发送的消息</span><br><span class="line">        ROS_INFO(<span class="string">&quot;发送的消息:%s&quot;</span>,msg.data.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span>根据前面制定的发送贫频率自动休眠 休眠时间 = <span class="number">1</span>/频率；</span><br><span class="line">        r.sleep();</span><br><span class="line">        count++;<span class="regexp">//</span>循环结束前，让 count 自增</span><br><span class="line">        <span class="regexp">//</span>暂无应用</span><br><span class="line">        ros::spinOnce();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消息订阅方:</span></span><br><span class="line"><span class="comment">        订阅话题并打印接收到的消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现流程:</span></span><br><span class="line"><span class="comment">        1.包含头文件 </span></span><br><span class="line"><span class="comment">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="comment">        3.实例化 ROS 句柄</span></span><br><span class="line"><span class="comment">        4.实例化 订阅者 对象</span></span><br><span class="line"><span class="comment">        5.处理订阅的消息(回调函数)</span></span><br><span class="line"><span class="comment">        6.设置循环调用回调函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 1.包含头文件 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doMsg</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg_p)</span>&#123;</span><br><span class="line">    ROS_INFO(<span class="string">&quot;我听见:%s&quot;</span>,msg_p-&gt;data.c_str());</span><br><span class="line">    <span class="comment">// ROS_INFO(&quot;我听见:%s&quot;,(*msg_p).data.c_str());</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>  *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setlocale(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    ros::init(argc,argv,<span class="string">&quot;listener&quot;</span>);</span><br><span class="line">    <span class="comment">//3.实例化 ROS 句柄</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.实例化 订阅者 对象</span></span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>,<span class="number">10</span>,doMsg);</span><br><span class="line">    <span class="comment">//5.处理订阅的消息(回调函数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     6.设置循环调用回调函数</span></span><br><span class="line">    ros::spin();<span class="comment">//循环读取接收的数据，并调用回调函数处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vscode报错</strong>  <code>fatal error: &#39;ros/ros.h&#39; file not found #include &quot;ros/ros.h&quot;</code>，在terminal中打开执行<code>catkin_make</code>，显示100% 没报错，是vs编译器设置错了。vs编译器设置成了<code>C/C++:clang++ build active file</code>，应在Terminal → Configure Default Build Task 中点击<code>catkin_make:build</code>右边的齿轮<u>修改tasks.json文件</u>（1.4.2 P28中有详细介绍）</p>
<p><strong>没设置INFO</strong> 发给接收方接收，没显示在显示端，用<code>rostopic echo 话题</code>查看。</p>
<p><code>rqt_graph</code> 查看节点关系（计算图）&lt;我还没安这个命令&gt;。</p>
<p><strong>python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    需求: 实现基本的话题通信，一方发布数据，一方接收数据，</span></span><br><span class="line"><span class="string">         实现的关键点:</span></span><br><span class="line"><span class="string">         1.发送方</span></span><br><span class="line"><span class="string">         2.接收方</span></span><br><span class="line"><span class="string">         3.数据(此处为普通文本)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         PS: 二者需要设置相同的话题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    消息发布方:</span></span><br><span class="line"><span class="string">        循环发布信息:HelloWorld 后缀数字编号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    实现流程:</span></span><br><span class="line"><span class="string">        1.导包 </span></span><br><span class="line"><span class="string">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="string">        3.实例化 发布者 对象</span></span><br><span class="line"><span class="string">        4.组织被发布的数据，并编写逻辑发布数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#1.导包 </span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;talker_p&quot;</span>)</span><br><span class="line">    <span class="comment">#3.实例化 发布者 对象</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;chatter&quot;</span>,String,queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#4.组织被发布的数据，并编写逻辑发布数据</span></span><br><span class="line">    msg = String()  <span class="comment">#创建 msg 对象</span></span><br><span class="line">    msg_front = <span class="string">&quot;hello 你好&quot;</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment">#计数器 </span></span><br><span class="line">    <span class="comment"># 设置循环频率</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line"></span><br><span class="line">        <span class="comment">#拼接字符串</span></span><br><span class="line">        msg.data = msg_front + <span class="built_in">str</span>(count)</span><br><span class="line"></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;写出的数据:%s&quot;</span>,msg.data)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    需求: 实现基本的话题通信，一方发布数据，一方接收数据，</span></span><br><span class="line"><span class="string">         实现的关键点:</span></span><br><span class="line"><span class="string">         1.发送方</span></span><br><span class="line"><span class="string">         2.接收方</span></span><br><span class="line"><span class="string">         3.数据(此处为普通文本)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    消息订阅方:</span></span><br><span class="line"><span class="string">        订阅话题并打印接收到的消息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    实现流程:</span></span><br><span class="line"><span class="string">        1.导包 </span></span><br><span class="line"><span class="string">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="string">        3.实例化 订阅者 对象</span></span><br><span class="line"><span class="string">        4.处理订阅的消息(回调函数)</span></span><br><span class="line"><span class="string">        5.设置循环调用回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#1.导包 </span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doMsg</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;I heard:%s&quot;</span>,msg.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;listener_p&quot;</span>)</span><br><span class="line">    <span class="comment">#3.实例化 订阅者 对象</span></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;chatter&quot;</span>,String,doMsg,queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#4.处理订阅的消息(回调函数)</span></span><br><span class="line">    <span class="comment">#5.设置循环调用回调函数</span></span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>实现对自定义消息的发布与订阅。</li>
</ol>
<p>std_msgs 封装了一些如String、Int32、Int64、Char、Bool、Empty的数据类型，这些数据一般只包含一个 data 字段，当传输如激光雷达的一些复杂数据时，结构的单一导致着功能上的局限性。</p>
<h5 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h5><p>服务通信基于<strong>请求响应</strong>模式，是一种应答机制，也即: 一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A。它更适用于对<u>实时性</u>有要求、具有一定<u>逻辑处理</u>的应用场景，如：机器人巡逻时，控制系统分析传感器数据发现可疑物体或人…此时拍摄照片并留存。</p>
<h5 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h5><p>用于实现不同节点之间的数据共享</p>
]]></content>
  </entry>
  <entry>
    <title>bookList</title>
    <url>/2022/07/05/bookList/</url>
    <content><![CDATA[<p>☁作为安全专业学生，还是多学学安全吧🤕身边大佬好像都在学二进制安全，我也来浅浅入门一下🤕代码之家看起来像个病毒网站，我之前下电子书都跳过它，没想到里面有这么多资源😇不可貌相</p>
<h5 id="1-逆向系列"><a href="#1-逆向系列" class="headerlink" title="1. 逆向系列"></a>1. 逆向系列</h5><p>《汇编语言》王爽老师的经典之作，了解学习基本的汇编指令，不论是pwn还是reverse都需要知道汇编的知识</p>
<p>《逆向工程权威指南》也是经典之作，逆向工程入门经典书籍</p>
<p>《C++<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E6%B1%87%E7%BC%96&spm=1001.2101.3001.7020">反汇编</a>与逆向分析技术揭秘》源代码和汇编结合举例，很详细，后面对熊猫烧香的分析也很详细</p>
<p>《Android软件安全与<a href="https://so.csdn.net/so/search?q=%E9%80%86%E5%90%91%E5%88%86%E6%9E%90&spm=1001.2101.3001.7020">逆向分析</a>》介绍安卓逆向基础，后面出了2019的版本，可以看看2019的版本</p>
<p>《逆向工程核心原理》逆向入门的好书，讲的非常细致，初学者可以买来看看</p>
<p>《恶意代码分析实战》案例较多，适合有基础的朋友们看</p>
<h5 id="2-操作系统基础"><a href="#2-操作系统基础" class="headerlink" title="2. 操作系统基础"></a>2. 操作系统基础</h5><p>《深入理解计算机系统》深入介绍计算机的原理，很详细，内容覆盖很广</p>
<p>《程序员的自我修养》深入讲解了ELF，PE文件的链接过程，PWN基础学习的好书。作者荐书：</p>
<p>intel手册 - <a href="http://www.intel.com/products/processor/manuals">http://www.intel.com/products/processor/manuals</a></p>
<img src="D:\blog\coriiiander\source\_posts\pictures\荐书1.png" alt="荐书1" style="zoom:67%;" />

<img src="D:\blog\coriiiander\source\_posts\pictures\荐书2.png" alt="荐书2" style="zoom:67%;" />

<p>《深入解析Windows操作系统》比较厚的书，分为上下册，详细的介绍了Windows的各种机制，就是不容易耐下性子来看 </p>
<h5 id="3-漏洞系列"><a href="#3-漏洞系列" class="headerlink" title="3. 漏洞系列"></a>3. 漏洞系列</h5><p>《0day安全 软件漏洞分析技术》漏洞学习基础,里面有许多类型的漏洞分析</p>
<p>《漏洞战争 软件漏洞分析精要》看完0day安全再看这本书，这本书以实战为主 </p>
<h5 id="4-内核系列"><a href="#4-内核系列" class="headerlink" title="4. 内核系列"></a>4. 内核系列</h5><p><strong>Windows内核</strong></p>
<p>《Windows内核情景分析》对内核的介绍非常详细，毛德操老师的著作</p>
<p>《寒江独钓-Windows内核安全编程》内核安全编程很著名的一本书，适合入门</p>
<p>《Windows内核安全与驱动开发》寒江独钓的升级版，年份上比寒江独钓新一些</p>
<p>《Windows驱动开发技术详解》驱动开发入门书籍</p>
<p><strong>Linux内核</strong></p>
<p>《深入理解Linux内核(第三版)》详细介绍了Linux内核的知识，很著名的一本书 </p>
<h5 id="5-编程系列"><a href="#5-编程系列" class="headerlink" title="5. 编程系列"></a>5. 编程系列</h5><p>《Windows黑客编程技术详解》里面有win32和内核的编程，介绍还算比较全面</p>
<p>《Python编程从入门到实践》基础的python入门书籍，小白都可以看的懂 </p>
<h5 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h5><p>《IDA Pro权威指南》深入理解IDA工具，神器不解释</p>
<p>《加密与解密第四版》里面有很多综合的知识，ctf入门书籍，能详细的读完这本书，就算是很厉害了</p>
]]></content>
  </entry>
  <entry>
    <title>Misc</title>
    <url>/2022/02/12/Misc/</url>
    <content><![CDATA[<blockquote>
<h4 id="二维码-扫描、分离隐藏文件，暴力破解压缩包"><a href="#二维码-扫描、分离隐藏文件，暴力破解压缩包" class="headerlink" title="二维码 - 扫描、分离隐藏文件，暴力破解压缩包"></a>二维码 - 扫描、分离隐藏文件，暴力破解压缩包</h4></blockquote>
<p>①<strong>binwalk扫描文件</strong>：发现隐藏文件，藏了一个压缩包<strong>在图片中</strong>。</p>
<img src="D:\CTF\notes' pictures\binwalkQR.png" alt="binwalkQR" style="zoom:70%;" />



<p>②<strong>分离隐藏文件</strong>：四种方法<a href="https://www.cnblogs.com/jiaxinguoguo/p/7351202.html">https://www.cnblogs.com/jiaxinguoguo/p/7351202.html</a></p>
<p>（1）<strong>dd命令</strong>分离隐藏文件：<code>dd if=QR_code.png of=flag1.zip skip=471 bs=1</code> </p>
<p>​    ※bs为其他值会报错“无法跳至指定偏移量”，且文件不正常。</p>
<ul>
<li><p><strong>LINUX dd命令：</strong></p>
<p>dd命令主要用来块拷贝一个指定大小的文件，并在拷贝的同时进行指定的转换。<u>参数注释：</u></p>
<p>1.if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</p>
<p>2.of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</p>
<p>3.skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</p>
<p>4.bs=bytes：设置读入/输出的块大小为bytes个字节。</p>
<p>……可以灵活使用参数进行<u>磁盘测试</u>etc.</p>
</li>
</ul>
<img src="D:\CTF\notes' pictures\binwalk更改skip.png" alt="binwalk更改skip" style="zoom:67%;" />

<p>（2）也可在<font color=#00BFFF>一定环境配置(java)下</font>使用**<code>binwalk -e</code>**来分离文件。</p>
<img src="D:\CTF\notes' pictures\binwalk -e报错.png" alt="binwalk -e报错" style="zoom:70%;" />



<p>③破解压缩包密码</p>
<p>（1）<strong>fcrackzip</strong>暴力破解<strong>zip</strong>压缩包密码：下载安装<code>sudo apt-get install fcrackzip</code>，命令<code>fcrackzip -b -c1 -l 1-4 -u /home/vivi/flag1.zip</code></p>
<ul>
<li>参数解释：-b 暴力破解模式，-c 指定掩码类型（a=a-z; 1=0-9; !=特殊字符），-l 密码长度，-u 压缩文件名</li>
</ul>
<p>※只能破解zip，rar就不行了。</p>
<p>（2）<strong>rar</strong>用<strong>ARCHPR</strong>：注意设置攻击类型、范围与掩码。</p>
<ul>
<li><font color=#00BFFF>攻击类型</font></li>
</ul>
<blockquote>
<h4 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h4></blockquote>
<p>1.万能的txt读程序源码</p>
<p>2.用html加载图片</p>
<img src="D:\CTF\notes' pictures\html加载图片.png" alt="html加载图片" style="zoom:67%;" />



<blockquote>
<h4 id="文件中的秘密"><a href="#文件中的秘密" class="headerlink" title="文件中的秘密"></a>文件中的秘密</h4></blockquote>
<p>图片属性中也能藏信息</p>
<blockquote>
<h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a><font color=#00BFFF>wireshark</font></h4></blockquote>
<p>wireshark&amp;被嗅探的流量两题，不知道wireshark怎么用。</p>
<blockquote>
<h4 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h4></blockquote>
<p>只可在无损压缩或者无压缩的图片（.bmp）上实现lsb隐写。</p>
<p>.jpg：对像数进行了<strong>有损</strong>压缩，<strong>无法用LSB隐写</strong>。</p>
<p>.bmp：把所有的像数都按原样储存，一般特别大，<strong>没有进行压缩</strong>。可LSB隐写。</p>
<p>.png：一种<strong>无损</strong>压缩的位图片形格式。可LSB隐写。</p>
<p>图像像数一般由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即共有256种颜色，一共包含了256的3次方的颜色，即16777216种颜色。而人类的眼睛可以区分约1000万种不同的颜色，这就意味着人类的眼睛无法区分余下的大约6777216种颜色。</p>
<img src="D:\CTF\notes' pictures\RGB.png" alt="RGB" style="zoom:50%;" />

<p>LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，每个像数可以携带<strong>3比特</strong>的信息。</p>
<img src="D:\CTF\notes' pictures\最低有效位.png" alt="最低有效位" style="zoom: 35%;" />

<p>图片通道：一幅完整的图像，红色绿色蓝色三个通道缺一不可。</p>
<blockquote>
<p>（PhotoShop中）关闭红色通道，图像偏青色；关闭绿色通道，图像偏红色；关闭蓝色通道，图像偏黄色；Alpha通道是一个8位的灰度通道，也可理解为透明度。</p>
</blockquote>
<p>配置java环境后用<strong>Stegsolve</strong>打开LSB隐写的图片，查看<code>Red plane 0</code>、<code>Grenn plane 0</code>、<code>Blue plane0</code>通道上方有东西，调整保存DataAnalyse数据生成图片。</p>
<img src="D:\CTF\notes' pictures\Stegsolve_BluePlane0.png" alt="Stegsolve_BluePlane0" style="zoom:50%;" />

<img src="D:\CTF\notes' pictures\StegsolveDataExtract.png" alt="StegsolveDataExtract" style="zoom:55%;" />



<blockquote>
<h4 id="zip伪加密-十六进制编辑器"><a href="#zip伪加密-十六进制编辑器" class="headerlink" title="zip伪加密 - 十六进制编辑器"></a>zip伪加密 - 十六进制编辑器</h4></blockquote>
<p>010editor template下载相关插件，修改参数。</p>
<p>zip伪加密：不需要真的解密，修改相应参数后再打开就不用密码了。一般在压缩源文件数据区全局方式位标记处，真加密为 09 00，伪加密为00 00，而这道题把两处标记全改过了，所以应当改两处。</p>
<img src="D:\CTF\notes' pictures\伪加密标记位.png" alt="伪加密标记位" style="zoom:70%;" />

<img src="D:\CTF\notes' pictures\010editor改参数.png" alt="010editor改参数" style="zoom:65%;" />



<blockquote>
<h4 id="另外一个世界"><a href="#另外一个世界" class="headerlink" title="另外一个世界"></a>另外一个世界</h4></blockquote>
<p>二进制八个一组转ASCII码</p>
<blockquote>
<h4 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h4></blockquote>
<p>.png中隐藏.zlib文件。</p>
<p>※**.zlib文件**：用于数据压缩的开源软件包。</p>
<p>Stegsolve打开图片，Data Analyse按上LSB加密设置（MSB也可）（主要是查看隐写）调出数据，看到文件头为504B0304（zip和zlib文件头一样）。各类型file的文件头尾：<a href="http://www.mamicode.com/info-detail-2468733.html%E3%80%82">http://www.mamicode.com/info-detail-2468733.html。</a></p>
<p>不用Windows自带的压缩器打开压缩包后看到一个无后缀的ELF文件。在其中查找“hctf”。</p>
<p>※<strong>ELF文件</strong>：一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。是UNIX系统实验室（USL）作为应用程序二进制接口而开发和发布的，也是Linux的主要可执行文件格式。</p>
<blockquote>
<h4 id="假如给我三天光明"><a href="#假如给我三天光明" class="headerlink" title="假如给我三天光明"></a>假如给我三天光明</h4></blockquote>
<p>用Audacity处理摩斯电码：200宽度的表示_ 50宽度的表示 . 距离50宽度的连读 50宽度外的表示停顿。</p>
<p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></p>
<blockquote>
<h4 id="神秘龙卷风"><a href="#神秘龙卷风" class="headerlink" title="神秘龙卷风"></a>神秘龙卷风</h4></blockquote>
<p>brainfuck（一种计算机语言）加密。<a href="http://bf.doleczek.pl/">http://bf.doleczek.pl/</a></p>
<blockquote>
<h4 id="后门查杀"><a href="#后门查杀" class="headerlink" title="后门查杀"></a>后门查杀</h4></blockquote>
<p>解压后用D盾。</p>
<p><strong>后门</strong>：指绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。有攻击者建立的后门，也有程序员自己在软件内创建后门以方便测试或者修改程序中的缺陷。后者在软件发布时，后门被有意或者无意忽视了，没有被删除，那么这个软件天生就存在后门，安装该软件的主机就不可避免的引入了后门。</p>
<blockquote>
<h4 id="荷兰宽带数据泄露"><a href="#荷兰宽带数据泄露" class="headerlink" title="荷兰宽带数据泄露"></a>荷兰宽带数据泄露</h4></blockquote>
<p>.bin 文件是一个路由配置文件，路由器信息数据，一般包含账号密码。</p>
<p>用<font color=#00BFFF>RouterPassView</font></p>
<blockquote>
<h4 id="面具下的flag"><a href="#面具下的flag" class="headerlink" title="面具下的flag"></a>面具下的flag</h4></blockquote>
<p>binwalk分离出压缩包，010editor修改伪加密（不修改伪加密linux上打不开压缩包，看不到vmdk文件），再在linux里解压vmdk文件（windows解不了压，linux里解压才能看到txt文件）</p>
<p><strong>vmdk文件</strong>：VMDK是虚拟机VMware创建的虚拟硬盘格式，文件存在于VMware文件系统中，被称为VMFS（虚拟机文件系统）。一个VMDK文件代表VMFS在虚拟机上的一个物理硬盘驱动。所有用户数据和有关虚拟服务器的配置信息都存储在VMDK文件中。</p>
<blockquote>
<h4 id="九连环"><a href="#九连环" class="headerlink" title="九连环"></a>九连环</h4></blockquote>
]]></content>
  </entry>
  <entry>
    <title>Web</title>
    <url>/2022/02/10/Web/</url>
    <content><![CDATA[<blockquote>
<h4 id="WarmUp"><a href="#WarmUp" class="headerlink" title="WarmUp"></a>WarmUp</h4></blockquote>
<p>代码审计：hint.php?../…/…/…/…/ffffllllaaaagggg 传入 checkFile( ) 要经历一次白名单验证、一次?过滤得 hint.php 再进行一次白名单验证返回为真，即得到flag。</p>
<p>☁<code>http://34774e72-ec93-4cf6-9472-b655238aff59.node4.buuoj.cn:81/index.php?file=hint.php?../../../../../ffffllllaaaagggg</code> <font color=#00BFFF>为什么有index.php?file=</font></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="comment">//highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">      </span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;<span class="variable">$page</span></span>)</span></span><br><span class="line"><span class="function">          //<span class="title">cehckFile</span>(<span class="params"></span>)进行了3次白名单检测、 2次问号过滤、一次<span class="title">URL</span>解码</span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">              <span class="comment">//白名单列表</span></span><br><span class="line">              <span class="variable">$whitelist</span> = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">              <span class="comment">//isset()检测变量是否已设置并且非 NULL;  </span></span><br><span class="line">              <span class="comment">//is_string()判断变量是否是字符串</span></span><br><span class="line">              <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="variable">$page</span>) || !<span class="title function_ invoke__">is_string</span>(<span class="variable">$page</span>)) &#123;</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it A&quot;</span>;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//检测传进来的值是否匹配白名单列表$whitelist</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//过滤问号的函数(如果$page的值有？则从?之前提取字符串)</span></span><br><span class="line">               <span class="comment">//mb_substr() 函数返回字符串的一部分，substr() 只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。</span></span><br><span class="line">             <span class="variable">$_page</span> = <span class="title function_ invoke__">mb_substr</span>(</span><br><span class="line">                 <span class="variable">$page</span>,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)//返回<span class="variable">$page</span>.里?号出现的第一个位置</span><br><span class="line">             );</span><br><span class="line"> </span><br><span class="line">              <span class="comment">//第二次检测传进来的值是否匹配白名单列表$whitelist</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//url对$page解码</span></span><br><span class="line">             <span class="variable">$_page</span> = <span class="title function_ invoke__">urldecode</span>(<span class="variable">$page</span>);</span><br><span class="line"> </span><br><span class="line">             <span class="comment">//第二次过滤问号的函数(如果$page的值有？则从?之前提取字符串)</span></span><br><span class="line">             <span class="variable">$_page</span> = <span class="title function_ invoke__">mb_substr</span>(</span><br><span class="line">                 <span class="variable">$_page</span>,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">             );</span><br><span class="line">             <span class="comment">//第三次检测传进来的值是否匹配白名单列表$whitelist</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; <span class="title function_ invoke__">is_string</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::<span class="title function_ invoke__">checkFile</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="comment">/*如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。</span></span><br><span class="line"><span class="comment">        否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。*/</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<h4 id="Include-1"><a href="#Include-1" class="headerlink" title="Include 1"></a>Include 1</h4></blockquote>
<p>靶场环境：<a href="http://78d5d456-3136-4627-9d09-4cdbb8f1af18.node4.buuoj.cn:81/">http://78d5d456-3136-4627-9d09-4cdbb8f1af18.node4.buuoj.cn:81</a></p>
<p>文件包含漏洞，读取代码（PHP伪协议）：<code>php://filter/read=convert.base64-encode/resource=xxx.php</code></p>
<p>然后构造playload：<code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></p>
<blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4></blockquote>
]]></content>
  </entry>
  <entry>
    <title>Reverse</title>
    <url>/2022/02/25/Reverse/</url>
    <content><![CDATA[<p>☁buu做题和《逆向工程核心原理》阅读笔记</p>
<h4 id="0x00-IDA"><a href="#0x00-IDA" class="headerlink" title="0x00 IDA"></a>0x00 IDA</h4><p>逆向工程分为动态分析(OLLYDBG)和静态分析(IDA)。IDA无法分析自解压运行(.exe)的文件，通常用OLLYDBG动态跟踪，等程序完成自解压后从内存中将解压后的代码完整的挖下来形成文件，再由IDA进行静态分析。</p>
<p><code>shift+F12</code>查找字符串    <code>ctrl+x</code>查看流程图    <code>F5</code>查看源代码</p>
<h4 id="0x01-OllyDBG"><a href="#0x01-OllyDBG" class="headerlink" title="0x01 OllyDBG"></a>0x01 OllyDBG</h4><p>《逆向工程核心原理》第二章</p>
<h4 id="0x02-壳"><a href="#0x02-壳" class="headerlink" title="0x02 壳"></a>0x02 壳</h4><p><code>exeinfo pe</code>查壳，发现是UPX-&gt;Markus &amp; …的壳。</p>
<img src="D:\CTF\notes' pictures\exeinfopeHappyNewYear.png" alt="exeinfopeHappyNewYear" style="zoom:50%;" />

<p><strong>壳</strong>：实质上是一个子程序，它在程序运行时首先取得控制权并对exe、com、和dll等程序文件进行压缩，同时隐藏程序真正的OEP。大多数病毒就是基于此原理，从而防止被杀毒软件扫描。</p>
<blockquote>
<p>EP是程序的入口点，OEP是程序的原始入口点。一个正常的程序只有EP，只有入口点被修改的程序（加壳等），才会拥有OEP。壳就是一把锁，OEP就是锁孔。</p>
<p>UPX：一种可执行程序文件压缩器/压缩壳，压缩壳主要功能是压缩PE文件(比如exe,dll等文件)。壳upx是一种保护程序，一般是EXE文件的一种外保护措施。</p>
</blockquote>
<p><font color=#FF0000><strong>ESP定律</strong>（堆栈平衡定律）脱壳（OllyDbg）：</font></p>
<h4 id="0x03-Abex’-crackme"><a href="#0x03-Abex’-crackme" class="headerlink" title="0x03 Abex’ crackme"></a>0x03 Abex’ crackme</h4><h5 id="Abex’-crackme-1"><a href="#Abex’-crackme-1" class="headerlink" title="Abex’ crackme #1"></a>Abex’ crackme #1</h5><blockquote>
<p>CD-Rom：compact disc read-only memory只读光盘</p>
<p>HDD：Hard Disk Drive</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>coriiiander&#39;s weekly</title>
    <url>/2022/06/20/weekly/</url>
    <content><![CDATA[<h4 id="0x00-2022-6-20-6-26"><a href="#0x00-2022-6-20-6-26" class="headerlink" title="0x00 2022/6/20-6/26"></a>0x00 2022/6/20-6/26</h4><ol>
<li>leetcode腾讯精选五十题*5（练JAVA/python），笔记发在leetcode题解上方便查看</li>
<li>ROS 安装&amp;ROS的HelloWorld C++/python简单实现</li>
<li>The Economist - Palm roiled &amp; Schumpeter</li>
<li>工训STC-B焊接及测试案例</li>
</ol>
<h4 id="0x01-6-27-7-3"><a href="#0x01-6-27-7-3" class="headerlink" title="0x01 6/27-7/3"></a>0x01 6/27-7/3</h4><ol>
<li>工训BSP编程</li>
<li>学了个微软双拼</li>
<li> 高铁上入门一下二进制安全，入门失败</li>
</ol>
<p>学习能力和学习效率也就这样了</p>
<img src="D:\blog\coriiiander\source\_posts\pictures\提问的智慧.png" alt="提问的智慧" style="zoom: 67%;" />

<h4 id="暑假日报"><a href="#暑假日报" class="headerlink" title="暑假日报"></a>暑假日报</h4><p><strong>7/4</strong> ROS看了第二章通信机制，代码还得着重理解一下。</p>
<p><strong>7/5</strong> 入门二进制安全，进个货先；看了《加密与解密第四版》第一章 基础知识。</p>
<p><strong>7/6</strong> 看了《0 day安全第一章》漏洞概述；《逆向工程核心原理》前两章 阅读第二章更全面地了解了OllyDbg的功能和使用；在考虑怎么高效做笔记。</p>
<p><strong>7/7</strong> 《程序员的自我修养》看到第一章温故知新 - 操作系统，这本书没其他几本好看；继续看《逆向》3 - 12章，第一部分 代码逆向技术基础书是看了，但是有很多实践的不是很理解，已标记下来。</p>
<p><strong>7/8</strong> 上班不敢摸鱼；下班简单看了一下《逆向》的PE文件格式，为了皮肤不敢熬夜；躺！</p>
<img src="D:\blog\coriiiander\source\_posts\pictures\上班第一天.jpg" alt="上班第一天" style="zoom: 67%;" />

<p><strong>7/9</strong> </p>
]]></content>
  </entry>
  <entry>
    <title>setupBlog</title>
    <url>/2022/06/20/setupBlog/</url>
    <content><![CDATA[<h4 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h4><p>参考保姆级教学<a href="https://b23.tv/MLKFY">https://b23.tv/MLKFY</a> B站永远的神！</p>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s</span></span><br><span class="line">Usage: hexo &lt;command&gt;</span><br></pre></td></tr></table></figure>

<p>没有打开最近具体文件的文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span></span><br><span class="line">...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/coriiiander/coriiiander.github.io.git/&#x27;: Failed to connect to localhost port 8080 after 150217 ms: Connection refused</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\blog\coriiiander\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (node:events:390:28)</span><br><span class="line">      at ChildProcess.cp.emit (D:\blog\coriiiander\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>

<p>把_config.yml http协议改成git协议。</p>
<p>新版<code>hexo d</code> 后直接部署，无须输入<code>token</code>。</p>
<h4 id="美化博客"><a href="#美化博客" class="headerlink" title="美化博客"></a>美化博客</h4><p>更换主题页面报错，注意查看github主题源模板处安装依赖提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">extends widget/base block append head link(rel=&#x27;stylesheet&#x27;, href= url_for(&quot;/style/widget-post-list.css&quot;)) block content include widget/widget-post-list block sidebar include widget/widget-search if theme.widgets.includes(&#x27;profile&#x27;) include widget/widget-profile if theme.widgets.includes(&#x27;recent_posts&#x27;) include widget/widget-recent if theme.widgets.includes(&#x27;category&#x27;) &amp;&amp; site.categories.length &gt; 0 include widget/widget-categories if theme.widgets.includes(&#x27;archive&#x27;) include widget/widget-archives if theme.widgets.includes(&#x27;tag&#x27;) &amp;&amp; site.tags.length &gt; 0 include widget/widget-tag </span><br></pre></td></tr></table></figure>

<p>本地部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>上传github</p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
